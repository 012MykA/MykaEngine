.\MykaEngine\CMakeLists.txt:
set(ENGINE_HEADERS
    "include/myka_camera.hpp"
    "include/myka_game_object.hpp"
    "include/myka_index_buffer.hpp"
    "include/myka_light.hpp"
    "include/myka_material.hpp"
    "include/myka_mesh.hpp"
    "include/myka_window.hpp"
    "include/myka_renderer.hpp"
    "include/myka_scene.hpp"
    "include/myka_shader.hpp"
    "include/myka_texture.hpp"
    "include/myka_timer.hpp"
    "include/myka_transform.hpp"
    "include/myka_vertex_array.hpp"
    "include/myka_vertex_buffer.hpp"
)

set(ENGINE_SOURCES
    "src/myka_camera.cpp"
    "src/myka_game_object.cpp"
    "src/myka_index_buffer.cpp"
    "src/myka_light.cpp"
    "src/myka_material.cpp"
    "src/myka_mesh.cpp"
    "src/myka_window.cpp"
    "src/myka_renderer.cpp"
    "src/myka_scene.cpp"
    "src/myka_shader.cpp"
    "src/myka_texture.cpp"
    "src/myka_timer.cpp"
    "src/myka_transform.cpp"
    "src/myka_vertex_array.cpp"
    "src/myka_vertex_buffer.cpp"
)

add_library(MykaEngine STATIC
    ${ENGINE_SOURCES}
    ${ENGINE_HEADERS}
)

target_include_directories(MykaEngine
    PUBLIC
        ${CMAKE_CURRENT_SOURCE_DIR}/include
    PRIVATE
        ${CMAKE_CURRENT_SOURCE_DIR}/src
)

target_link_libraries(MykaEngine PRIVATE
    glfw
)

.\MykaEngine\include\myka_camera.hpp:
#pragma once

#include <algorithm>

#include <GLFW/glfw3.h>
#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>

#include "myka_timer.hpp"

namespace MykaEngine
{
    class Camera
    {
    public:
        Camera(float width, float height, GLFWwindow *window);

        void onUpdate();

        void handleInputs();

    public:
        const glm::mat4 &getViewMatrix() const;
        const glm::mat4 &getProjectionMatrix() const;
        const glm::vec3 &getPosition() const;

        void setPosition(const glm::vec3& position);

    private:
        void updateViewMatrix();
        void updateProjectionMatrix();

        glm::vec3 m_Position{0.0f, 0.0f, 2.0f};
        glm::vec3 m_Front{0.0, 0.0f, -1.0f};
        glm::vec3 m_Up{0.0f, 1.0f, 0.0f};
        float m_Yaw = -90.0f;
        float m_Pitch = 0.0f;

        float m_FOV = 70;
        float m_Near = 0.01f;
        float m_Far = 10000.0f;

        float m_Velocity = 1.0f;

        float m_Width;
        float m_Height;
        GLFWwindow *m_Window;

        glm::mat4 m_ViewMatrix;
        glm::mat4 m_ProjectionMatrix;

        bool m_FirstClick = true;
        float m_MouseSensitivity = 0.05f;
        double m_LastX;
        double m_LastY;
    };
} // namespace MykaEngine

.\MykaEngine\include\myka_game_object.hpp:
#pragma once

#include "myka_mesh.hpp"
#include "myka_material.hpp"
#include "myka_transform.hpp"

// std
#include <memory>
#include <string>

namespace MykaEngine
{
    class GameObject
    {
    public:
        GameObject(std::shared_ptr<Mesh> mesh, std::shared_ptr<Material> material, const std::string &name = "GameObject");

    public:
        std::shared_ptr<Mesh> getMesh() const;
        std::shared_ptr<Material> getMaterial() const;
        Transform &getTransform();
        const Transform &getTransform() const;
        const std::string &getName() const;

    private:
        std::string m_Name;
        std::shared_ptr<Mesh> m_Mesh;
        std::shared_ptr<Material> m_Material;
        Transform m_Transform;
    };
} // namespace MykaEngine

.\MykaEngine\include\myka_index_buffer.hpp:
#pragma once

#include <glad/glad.h>

// std
#include <vector>

namespace MykaEngine
{
    class IndexBuffer
    {
    public:
        IndexBuffer();
        ~IndexBuffer();

        void bufferData(const std::vector<GLuint>& indices);

        void bind() const;
        void unbind() const;

    public:
        uint32_t getCount() const;

    private:
        uint32_t m_Count;
        GLuint m_ID;
    };
} // namespace MykaEngine

.\MykaEngine\include\myka_light.hpp:
#pragma once

#include <glm/glm.hpp>

// std
#include <memory>

namespace MykaEngine
{
    class Light
    {
    public:
        Light(const glm::vec3 &position,
              const glm::vec3 &color,
              const glm::vec3 &ambient,
              const glm::vec3 &diffuse,
              const glm::vec3 &specular);

    public:
        void setPosition(const glm::vec3 &position);

        const glm::vec3 &getPosition() const;
        const glm::vec3 &getColor() const;
        const glm::vec3 &getAmbient() const;
        const glm::vec3 &getDiffuse() const;
        const glm::vec3 &getSpecular() const;

    private:
        glm::vec3 m_Position;
        glm::vec3 m_Color;
        glm::vec3 m_Ambient;
        glm::vec3 m_Diffuse;
        glm::vec3 m_Specular;
    };
} // namespace MykaEngine

.\MykaEngine\include\myka_material.hpp:
#pragma once

#include "myka_shader.hpp"
#include "myka_texture.hpp"
#include "myka_light.hpp"

#include <glm/glm.hpp>

// std
#include <memory>

namespace MykaEngine
{
    class Material
    {
    public:
        Material(std::shared_ptr<Shader> shader, std::shared_ptr<Texture> texture);

    public:
        void bindShader() const;
        void bindTexture() const;
        void setUniforms(const glm::mat4 &model, const glm::mat4 &view, const glm::mat4 &proj, const Light& light, bool isLight) const;

    public:
        void setColor(const glm::vec3 &color);

        const glm::vec3& getColor() const;

    public: // TODO: private
        std::shared_ptr<Shader> m_Shader;
        std::shared_ptr<Texture> m_Texture;

        glm::vec3 m_Color = glm::vec3(1.0f);
        float m_Shininess = 32.0f;
    };
} // namespace MykaEngine

.\MykaEngine\include\myka_mesh.hpp:
#pragma once

#include "myka_vertex_array.hpp"
#include "myka_vertex_buffer.hpp"
#include "myka_index_buffer.hpp"

// std
#include <vector>

namespace MykaEngine
{
    class Mesh
    {
    public:
        Mesh(const std::vector<Vertex>& vertices, const std::vector<GLuint>& indices);

        void bind() const;
        void unbind() const;

        uint32_t getIndexCount() const;
        
    private:
        std::vector<Vertex> m_Vertices;
        std::vector<GLuint> m_Indices;

        VertexArray m_VAO;
        VertexBuffer m_VBO;
        IndexBuffer m_IBO;
    };
} // namespace MykaEngine

.\MykaEngine\include\myka_renderer.hpp:
#pragma once

#include <glad/glad.h>

#include "myka_mesh.hpp"
#include "myka_material.hpp"
#include "myka_game_object.hpp"
#include "myka_camera.hpp"
#include "myka_scene.hpp"

namespace MykaEngine
{
    class Renderer
    {
    public:
        Renderer() = default;
        ~Renderer() = default;

        void clear() const;
        
        void drawScene(const Scene& scene, const Camera camera) const;

    public:
        void drawObject(const GameObject& object, const Camera& camera, const Light &light, bool isLight) const;
    };
} // namespace MykaEngine

.\MykaEngine\include\myka_scene.hpp:
#pragma once

#include "myka_game_object.hpp"
#include "myka_light.hpp"

// std
#include <vector>
#include <memory>

namespace MykaEngine
{
    class Scene
    {
    public:
        Scene() = default;
        ~Scene() = default;
        
        void addGameObject(std::shared_ptr<GameObject> object);
        void addLight(std::shared_ptr<Light> light);

        void clear();
    
    public:
        const std::vector<std::shared_ptr<GameObject>>& getGameObjects() const;
        const std::vector<std::shared_ptr<Light>>& getLights() const;

    private:
        std::vector<std::shared_ptr<GameObject>> m_GameObjects;
        std::vector<std::shared_ptr<Light>> m_Lights;
    };
} // namespace MykaEngine

.\MykaEngine\include\myka_shader.hpp:
#pragma once

#include <glad/glad.h>
#include <glm/glm.hpp>
#include <glm/gtc/type_ptr.hpp>

// std
#include <iostream>
#include <filesystem>
#include <string>
#include <fstream>
#include <sstream>
#include <unordered_map>

namespace MykaEngine
{
    class Shader
    {
    public:
        Shader(const std::filesystem::path &vertexPath, const std::filesystem::path &fragmentPath);
        ~Shader();

        void use() const;

    public:
        void setUniform3f(const std::string &name, const glm::vec3 &value);
        void setUniform4f(const std::string &name, const glm::vec4 &value);
        void setUniform1i(const std::string &name, int value);
        void setUniform1f(const std::string &name, float value);
        void setUniformMat4f(const std::string &name, const glm::mat4& value);

    private:
        void compileShaders();
        GLint getUniformLocation(const std::string &name);
        std::string getFileContent(const std::filesystem::path &path);

        GLuint m_Program;
        std::unordered_map<std::string, GLint> m_UniformLocationCache;

        std::string m_VertexData;
        std::string m_FragmentData;
    };
} // namespace MykaEngine

.\MykaEngine\include\myka_texture.hpp:
#pragma once

#include <glad/glad.h>
#include <stb_image.h>

// std
#include <string>

namespace MykaEngine
{
    class Texture
    {
    public:
        Texture(const std::string& path);
        ~Texture();

        void bind(GLuint slot = 0) const;
        void unbind() const;

    private:
        GLuint m_RendererID = 0;
        std::string m_FilePath;
        unsigned char* m_LocalBuffer = nullptr;
        int m_Width = 0;
        int m_Height = 0;
        int m_BPP = 0;
    };
} // namespace MykaEngine

.\MykaEngine\include\myka_timer.hpp:
#pragma once

#include <GLFW/glfw3.h>

namespace MykaEngine
{
    class Timer
    {
    public:
        Timer() = delete;

        static void onUpdate();
        static float getDeltaTime() { return m_DeltaTime; }

    private:
        inline static float m_DeltaTime = 0;
        inline static float m_LastFrame = static_cast<float>(glfwGetTime());
    };
} // namespace MykaEngine

.\MykaEngine\include\myka_transform.hpp:
#pragma once

#include <glm/glm.hpp>
#include <glm/gtc/matrix_transform.hpp>
#include <glm/gtc/type_ptr.hpp>

namespace MykaEngine
{
    class Transform
    {
    public:
        Transform();

    public:
        void setPosition(const glm::vec3& position);
        void setRotation(const glm::vec3& rotation);
        void rotate(const glm::vec3& rotation);
        void setScale(const glm::vec3& scale);

        const glm::vec3& getPosition() const;
        const glm::vec3& getRotation() const;
        const glm::vec3& getScale() const;

        const glm::mat4& getModelMatrix() const;

    private:
        void updateModelMatrix();

        glm::vec3 m_Position{0.0f};
        glm::vec3 m_Rotation{0.0f};
        glm::vec3 m_Scale{1.0f};

        glm::mat4 m_ModelMatrix{1.0f};
    };
} // namespace MykaEngine

.\MykaEngine\include\myka_vertex_array.hpp:
#pragma once

#include <glad/glad.h>

namespace MykaEngine
{
    class VertexArray
    {
    public:
        VertexArray();
        ~VertexArray();

        void bind() const;
        void unbind() const;

    private:
        GLuint m_ID;
    };
} // namespace MykaEngine

.\MykaEngine\include\myka_vertex_buffer.hpp:
#pragma once

#include <glm/glm.hpp>
#include <glad/glad.h>

// std
#include <vector>

namespace MykaEngine
{
    struct Vertex
    {
        glm::vec3 position;
        glm::vec2 texCoord;
        glm::vec3 normal;
    };

    class VertexBuffer
    {
    public:
        VertexBuffer();
        ~VertexBuffer();

        void bufferData(const std::vector<Vertex>& vertices);
        void vertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid* pointer);

        void bind() const;
        void unbind() const;

    private:
        GLuint m_ID;
    };
} // namespace MykaEngine
.\MykaEngine\include\myka_window.hpp:
#pragma once

#include <glad/glad.h>
#include <GLFW/glfw3.h>

// std
#include <string>
#include <stdexcept>

namespace MykaEngine
{
    class MykaWindow
    {
    public:
        MykaWindow(uint32_t width, uint32_t height, const std::string& title, bool fullscreen);
        ~MykaWindow();

        MykaWindow(const MykaWindow&) = delete;
        MykaWindow& operator=(const MykaWindow&) = delete;

        bool shouldClose() const;

        void pollEvents() const;
        void swapBuffers() const;

        void setWindowTitle(const std::string& title);
    
    public:
        GLFWwindow* getWindow();

    private:
        static void framebufferSizeCallback(GLFWwindow* window, int width, int height);

        std::string m_Title;
        uint32_t m_Width;
        uint32_t m_Height;

        GLFWmonitor* m_Monitor;
        GLFWwindow* m_Window;
    };
} // namespace MykaEngine

.\MykaEngine\src\myka_camera.cpp:
#include "myka_camera.hpp"

namespace MykaEngine
{
    Camera::Camera(float width, float height, GLFWwindow *window)
        : m_Width(width), m_Height(height), m_Window(window)
    {
        glfwSetInputMode(m_Window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);

        updateViewMatrix();
        updateProjectionMatrix();
    }

    const glm::mat4 &Camera::getViewMatrix() const
    {
        return m_ViewMatrix;
    }

    const glm::mat4 &Camera::getProjectionMatrix() const
    {
        return m_ProjectionMatrix;
    }

    const glm::vec3 &Camera::getPosition() const
    {
        return m_Position;
    }

    void Camera::setPosition(const glm::vec3 &position)
    {
        m_Position = position;
    }

    void Camera::updateProjectionMatrix()
    {
        float aspectRatio = m_Width / m_Height;
        m_ProjectionMatrix = glm::perspective(glm::radians(m_FOV), aspectRatio, m_Near, m_Far);
    }

    void Camera::updateViewMatrix()
    {
        glm::vec3 front;
        front.x = cos(glm::radians(m_Yaw)) * cos(glm::radians(m_Pitch));
        front.y = sin(glm::radians(m_Pitch));
        front.z = sin(glm::radians(m_Yaw)) * cos(glm::radians(m_Pitch));
        m_Front = glm::normalize(front);

        m_ViewMatrix = glm::lookAt(m_Position, m_Position + m_Front, m_Up);
    }

    void Camera::handleInputs()
    {
        if (glfwGetKey(m_Window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
        {
            glfwSetInputMode(m_Window, GLFW_CURSOR, GLFW_CURSOR_NORMAL);
            m_FirstClick = true;
            return;
        }

        if (glfwGetInputMode(m_Window, GLFW_CURSOR) == GLFW_CURSOR_NORMAL)
        {
            if (glfwGetMouseButton(m_Window, GLFW_MOUSE_BUTTON_LEFT) == GLFW_PRESS)
            {
                glfwSetInputMode(m_Window, GLFW_CURSOR, GLFW_CURSOR_DISABLED);
            }
            return;
        }

        float velocity = m_Velocity * Timer::getDeltaTime();
        glm::vec3 right = glm::normalize(glm::cross(m_Front, m_Up));

        if (glfwGetKey(m_Window, GLFW_KEY_W) == GLFW_PRESS)
            m_Position += m_Front * velocity;
        if (glfwGetKey(m_Window, GLFW_KEY_S) == GLFW_PRESS)
            m_Position -= m_Front * velocity;
        if (glfwGetKey(m_Window, GLFW_KEY_A) == GLFW_PRESS)
            m_Position -= right * velocity;
        if (glfwGetKey(m_Window, GLFW_KEY_D) == GLFW_PRESS)
            m_Position += right * velocity;

        if (glfwGetKey(m_Window, GLFW_KEY_LEFT_CONTROL) == GLFW_PRESS)
            m_Position -= m_Up * velocity;
        if (glfwGetKey(m_Window, GLFW_KEY_SPACE) == GLFW_PRESS)
            m_Position += m_Up * velocity;

        double xpos, ypos;
        glfwGetCursorPos(m_Window, &xpos, &ypos);

        if (m_FirstClick)
        {
            m_LastX = xpos;
            m_LastY = ypos;
            m_FirstClick = false;
        }

        float xoffset = (float)(xpos - m_LastX) * m_MouseSensitivity;
        float yoffset = (float)(m_LastY - ypos) * m_MouseSensitivity;

        m_LastX = xpos;
        m_LastY = ypos;

        m_Yaw += xoffset;
        m_Pitch += yoffset;

        if (m_Pitch > 89.0f)
            m_Pitch = 89.0f;
        if (m_Pitch < -89.0f)
            m_Pitch = -89.0f;
        
        glfwSetCursorPos(m_Window, m_Width / 2.0, m_Height / 2.0);
        m_LastX = m_Width / 2.0;
        m_LastY = m_Height / 2.0;
    }

    void Camera::onUpdate()
    {
        updateViewMatrix();
        updateProjectionMatrix();
    }
} // namespace MykaEngine
.\MykaEngine\src\myka_game_object.cpp:
#include "myka_game_object.hpp"

namespace MykaEngine
{
    GameObject::GameObject(std::shared_ptr<Mesh> mesh, std::shared_ptr<Material> material, const std::string &name)
        : m_Mesh(mesh), m_Material(material), m_Name(name) {}

    std::shared_ptr<Mesh> GameObject::getMesh() const
    {
        return m_Mesh;
    }

    std::shared_ptr<Material> GameObject::getMaterial() const
    {
        return m_Material;
    }

    Transform &GameObject::getTransform()
    {
        return m_Transform;
    }

    const Transform &GameObject::getTransform() const
    {
        return m_Transform;
    }

    const std::string &GameObject::getName() const
    {
        return m_Name;
    }
} // namespace MykaEngine

.\MykaEngine\src\myka_index_buffer.cpp:
#include "myka_index_buffer.hpp"

namespace MykaEngine
{
    IndexBuffer::IndexBuffer() : m_Count{}
    {
        glGenBuffers(1, &m_ID);
    }

    IndexBuffer::~IndexBuffer()
    {
        glDeleteBuffers(1, &m_ID);
    }

    void IndexBuffer::bufferData(const std::vector<GLuint> &indices)
    {
        glBufferData(GL_ELEMENT_ARRAY_BUFFER, indices.size() * sizeof(GLuint), indices.data(), GL_STATIC_DRAW);
        m_Count = indices.size();
    }

    void IndexBuffer::bind() const
    {
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, m_ID);
    }

    void IndexBuffer::unbind() const
    {
        glBindBuffer(GL_ELEMENT_ARRAY_BUFFER, 0);
    }

    uint32_t IndexBuffer::getCount() const
    {
        return m_Count;
    }
} // namespace MykaEngine

.\MykaEngine\src\myka_light.cpp:
#include "myka_light.hpp"

namespace MykaEngine
{
    Light::Light(const glm::vec3 &position,
                 const glm::vec3 &color,
                 const glm::vec3 &ambient,
                 const glm::vec3 &diffuse,
                 const glm::vec3 &specular)
        : m_Position(position), m_Color(color), m_Ambient(ambient), m_Diffuse(diffuse), m_Specular(specular) {}

    void Light::setPosition(const glm::vec3 &position)
    {
        m_Position = position;
    }

    const glm::vec3 &Light::getPosition() const
    {
        return m_Position;
    }

    const glm::vec3 &Light::getColor() const
    {
        return m_Color;
    }

    const glm::vec3 &Light::getAmbient() const
    {
        return m_Ambient;
    }

    const glm::vec3 &Light::getDiffuse() const
    {
        return m_Diffuse;
    }

    const glm::vec3 &Light::getSpecular() const
    {
        return m_Specular;
    }

} // namespace MykaEngine

.\MykaEngine\src\myka_material.cpp:
#include "myka_material.hpp"

namespace MykaEngine
{
    Material::Material(std::shared_ptr<Shader> shader, std::shared_ptr<Texture> texture) : m_Shader(shader), m_Texture(texture) {}

    void Material::bindShader() const
    {
        m_Shader->use();
    }

    void Material::bindTexture() const
    {
        m_Texture->bind(0);
    }

    void Material::setUniforms(const glm::mat4 &model, const glm::mat4 &view, const glm::mat4 &proj, const Light& light, bool isLight) const
    {
        m_Shader->use();

        glm::mat4 mvp = proj * view * model;

        m_Shader->setUniformMat4f("u_MVP", mvp);
        if (!isLight)
        {
            m_Shader->setUniform1i("u_Texture", 0);
        }
        m_Shader->setUniform3f("u_LightColor", light.getColor());
    }

    void Material::setColor(const glm::vec3 &color)
    {
        m_Color = color;
    }

    const glm::vec3 &Material::getColor() const
    {
        return m_Color;
    }
} // namespace MykaEngine

.\MykaEngine\src\myka_mesh.cpp:
#include "myka_mesh.hpp"

namespace MykaEngine
{
    Mesh::Mesh(const std::vector<Vertex> &vertices, const std::vector<GLuint> &indices) : m_Vertices(vertices), m_Indices(indices)
    {
        m_VAO.bind();

        m_VBO.bind();
        m_VBO.bufferData(m_Vertices);

        m_IBO.bind();
        m_IBO.bufferData(m_Indices);

        m_VBO.vertexAttribPointer(0, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)0);
        m_VBO.vertexAttribPointer(1, 2, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)(3 * sizeof(float)));
        m_VBO.vertexAttribPointer(2, 3, GL_FLOAT, GL_FALSE, sizeof(Vertex), (void *)(5 * sizeof(float)));

        m_IBO.unbind();
        m_VBO.unbind();
        m_VAO.unbind();
    }

    void Mesh::bind() const
    {
        m_VAO.bind();
        m_IBO.bind();
    }
    
    void Mesh::unbind() const
    {
        m_VAO.unbind();
        m_IBO.unbind();
    }

    uint32_t Mesh::getIndexCount() const
    {
        return m_IBO.getCount();
    }
} // namespace MykaEngine

.\MykaEngine\src\myka_renderer.cpp:
#include "myka_renderer.hpp"

namespace MykaEngine
{
    void Renderer::clear() const
    {
        glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
    }

    void Renderer::drawScene(const Scene &scene, const Camera camera) const
    {
        if (scene.getLights().empty())
        {
            return;
        }

        const auto& light = *scene.getLights()[0];

        for (const auto& object : scene.getGameObjects())
        {
            // drawObject(*object, camera, light);
        }
    }

    void Renderer::drawObject(const GameObject &object, const Camera &camera, const Light& light, bool isLight) const
    {
        const auto& transform = object.getTransform();
        const auto& material = object.getMaterial();
        const auto& mesh = object.getMesh();

        glm::mat4 model = transform.getModelMatrix();
        glm::mat4 view = camera.getViewMatrix();
        glm::mat4 proj = camera.getProjectionMatrix();

        material->bindShader();
        material->setUniforms(model, view, proj, light, isLight);
        material->bindTexture();
        
        mesh->bind();

        glDrawElements(GL_TRIANGLES, static_cast<GLsizei>(mesh->getIndexCount()), GL_UNSIGNED_INT, 0);

        mesh->unbind();
    }
} // namespace MykaEngine

.\MykaEngine\src\myka_scene.cpp:
#include "myka_scene.hpp"

namespace MykaEngine
{
    void Scene::addGameObject(std::shared_ptr<GameObject> object)
    {
        m_GameObjects.push_back(object);
    }

    void Scene::addLight(std::shared_ptr<Light> light)
    {
        m_Lights.push_back(light);
    }

    void Scene::clear()
    {
        m_GameObjects.clear();
        m_Lights.clear();
    }

    const std::vector<std::shared_ptr<GameObject>> &Scene::getGameObjects() const
    {
        return m_GameObjects;
    }

    const std::vector<std::shared_ptr<Light>> &Scene::getLights() const
    {
        return m_Lights;
    }
} // namespace MykaEngine

.\MykaEngine\src\myka_shader.cpp:
#include "myka_shader.hpp"

namespace MykaEngine
{
    Shader::Shader(const std::filesystem::path &vertexPath, const std::filesystem::path &fragmentPath)
    {
        this->m_VertexData = getFileContent(vertexPath);
        this->m_FragmentData = getFileContent(fragmentPath);
        compileShaders();
    }

    Shader::~Shader()
    {
        glUseProgram(0);
    }

    void Shader::use() const
    {
        glUseProgram(m_Program);
    }

    void Shader::setUniform3f(const std::string &name, const glm::vec3 &value)
    {
        glUniform3f(getUniformLocation(name), value.x, value.y, value.z);
    }

    void Shader::setUniform4f(const std::string &name, const glm::vec4 &value)
    {
        glUniform4f(getUniformLocation(name), value.x, value.y, value.z, value.w);
    }

    void Shader::setUniform1i(const std::string &name, int value)
    {
        glUniform1i(getUniformLocation(name), value);
    }

    void Shader::setUniform1f(const std::string &name, float value)
    {
        glUniform1f(getUniformLocation(name), value);
    }

    void Shader::setUniformMat4f(const std::string &name, const glm::mat4 &matrix)
    {
        glUniformMatrix4fv(getUniformLocation(name), 1, GL_FALSE, glm::value_ptr(matrix));
    }

    void Shader::compileShaders()
    {
        GLuint vs;
        GLuint fs;
        GLint successful;
        GLchar GLInfoLog[512];

        vs = glCreateShader(GL_VERTEX_SHADER);
        fs = glCreateShader(GL_FRAGMENT_SHADER);

        const char *vs_char = m_VertexData.c_str();
        const char *fs_char = m_FragmentData.c_str();

        glShaderSource(vs, 1, &vs_char, 0);
        glShaderSource(fs, 1, &fs_char, 0);

        glCompileShader(vs);

        glGetShaderiv(vs, GL_COMPILE_STATUS, &successful);

        if (!successful)
        {
            glGetShaderInfoLog(vs, 512, NULL, GLInfoLog);
            std::cerr << "\nCOMPILATION ERROR IN VERTEX SHADER\n"
                      << GLInfoLog << std::endl;
        }

        glCompileShader(fs);
        glGetShaderiv(fs, GL_COMPILE_STATUS, &successful);

        if (!successful)
        {
            glGetShaderInfoLog(fs, 512, NULL, GLInfoLog);
            std::cerr << "\nCOMPILATION ERROR IN FRAGMENT SHADER\n"
                      << GLInfoLog << std::endl;
        }

        m_Program = glCreateProgram();
        glAttachShader(m_Program, vs);
        glAttachShader(m_Program, fs);
        glLinkProgram(m_Program);

        glGetProgramiv(m_Program, GL_LINK_STATUS, &successful);

        if (!successful)
        {
            glGetProgramInfoLog(m_Program, 512, NULL, GLInfoLog);
            std::cerr << "ERROR: SHADER LINKING FAILED: \n"
                      << GLInfoLog << std::endl;
        }

        glDeleteShader(vs);
        glDeleteShader(fs);
    }

    GLint Shader::getUniformLocation(const std::string &name)
    {
        if (m_UniformLocationCache.find(name) != m_UniformLocationCache.end())
        {
            return m_UniformLocationCache[name];
        }
        GLint location = glGetUniformLocation(m_Program, name.c_str());
        if (location == -1)
        {
            std::cerr << "failed to find uniform: '" << name << "'" << std::endl;
            return -1;
        }
        m_UniformLocationCache[name] = location;
        return location;
    }

    std::string Shader::getFileContent(const std::filesystem::path &path)
    {
        std::ifstream file(path);

        if (!file.is_open())
        {
            std::cerr << "failed to open file: " << path << std::endl;
            return "";
        }
        std::stringstream buffer;
        buffer << file.rdbuf();

        file.close();

        return buffer.str();
    }
} // namespace MykaEngine

.\MykaEngine\src\myka_texture.cpp:
#include "myka_texture.hpp"

namespace MykaEngine
{

    Texture::Texture(const std::string &path) : m_FilePath(path)
    {
        stbi_set_flip_vertically_on_load(1);
        m_LocalBuffer = stbi_load(path.c_str(), &m_Width, &m_Height, &m_BPP, 4);

        glGenTextures(1, &m_RendererID);
        glBindTexture(GL_TEXTURE_2D, m_RendererID);

        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_LINEAR);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_CLAMP_TO_EDGE);
        glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_CLAMP_TO_EDGE);

        glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA8, m_Width, m_Height, 0, GL_RGBA, GL_UNSIGNED_BYTE, m_LocalBuffer);
        glBindTexture(GL_TEXTURE_2D, 0);

        if (m_LocalBuffer)
            stbi_image_free(m_LocalBuffer);
    }

    Texture::~Texture()
    {
        glDeleteTextures(1, &m_RendererID);
    }

    void Texture::bind(GLuint slot) const
    {
        glActiveTexture(GL_TEXTURE0 + slot);
        glBindTexture(GL_TEXTURE_2D, m_RendererID);
    }

    void Texture::unbind() const
    {
        glBindTexture(GL_TEXTURE_2D, 0);
    }
} // namespace MykaEngine

.\MykaEngine\src\myka_timer.cpp:
#include "myka_timer.hpp"

namespace MykaEngine
{
    void Timer::onUpdate()
    {
        m_DeltaTime = static_cast<float>(glfwGetTime()) - m_LastFrame;
        m_LastFrame = static_cast<float>(glfwGetTime());
    }
} // namespace MykaEngine

.\MykaEngine\src\myka_transform.cpp:
#include "myka_transform.hpp"

namespace MykaEngine
{
    Transform::Transform()
    {
        updateModelMatrix();
    }

    // Set
    void Transform::setPosition(const glm::vec3 &position)
    {
        m_Position = position;
        updateModelMatrix();
    }

    void Transform::setRotation(const glm::vec3 &rotation)
    {
        m_Rotation = rotation;
        updateModelMatrix();
    }

    void Transform::rotate(const glm::vec3 &rotation)
    {
        m_Rotation += rotation;
        updateModelMatrix();
    }

    void Transform::setScale(const glm::vec3 &scale)
    {
        m_Scale = scale;
        updateModelMatrix();
    }

    const glm::vec3 &Transform::getPosition() const
    {
        return m_Position;
    }

    const glm::vec3 &Transform::getRotation() const
    {
        return m_Rotation;
    }

    const glm::vec3 &Transform::getScale() const
    {
        return m_Scale;
    }

    const glm::mat4 &Transform::getModelMatrix() const
    {
        return m_ModelMatrix;
    }

    void Transform::updateModelMatrix()
    {
        glm::mat4 model{1.0f};

        model = glm::translate(model, m_Position);
        
        model = glm::rotate(model, glm::radians(m_Rotation.x), glm::vec3(1.0f, 0.0f, 0.0f));
        model = glm::rotate(model, glm::radians(m_Rotation.y), glm::vec3(0.0f, 1.0f, 0.0f));
        model = glm::rotate(model, glm::radians(m_Rotation.z), glm::vec3(0.0f, 0.0f, 1.0f));
        
        model = glm::scale(model, m_Scale);

        m_ModelMatrix = model;
    }
} // namespace MykaEngine

.\MykaEngine\src\myka_vertex_array.cpp:
#include "myka_vertex_array.hpp"

namespace MykaEngine
{
    VertexArray::VertexArray()
    {
        glGenVertexArrays(1, &m_ID);
    }

    VertexArray::~VertexArray()
    {
        glDeleteVertexArrays(1, &m_ID);
        this->unbind();
    }

    void VertexArray::bind() const
    {
        glBindVertexArray(m_ID);
    }

    void VertexArray::unbind() const
    {
        glBindVertexArray(0);
    }
} // namespace MykaEngine
.\MykaEngine\src\myka_vertex_buffer.cpp:
#include "myka_vertex_buffer.hpp"

namespace MykaEngine
{
    VertexBuffer::VertexBuffer() : m_ID{}
    {
        glGenBuffers(1, &m_ID);
    }

    VertexBuffer::~VertexBuffer()
    {
        glDeleteBuffers(1, &m_ID);
        this->unbind();
    }

    void VertexBuffer::bufferData(const std::vector<Vertex>& vertices)
    {
        glBufferData(GL_ARRAY_BUFFER, vertices.size() * sizeof(Vertex), vertices.data(), GL_STATIC_DRAW);
    }

    void VertexBuffer::vertexAttribPointer(GLuint index, GLint size, GLenum type, GLboolean normalized, GLsizei stride, const GLvoid *pointer)
    {
        glVertexAttribPointer(index, size, type, normalized, stride, pointer);
        glEnableVertexAttribArray(index);
    }

    void VertexBuffer::bind() const
    {
        glBindBuffer(GL_ARRAY_BUFFER, m_ID);
    }

    void VertexBuffer::unbind() const
    {
        glBindBuffer(GL_ARRAY_BUFFER, 0);
    }
} // namespace MykaEngine

.\MykaEngine\src\myka_window.cpp:
#include "myka_window.hpp"

namespace MykaEngine
{
    MykaWindow::MykaWindow(uint32_t width, uint32_t height, const std::string &title, bool fullscreen) : m_Width(width), m_Height(height), m_Title(title)
    {
        if (!glfwInit())
        {
            throw std::runtime_error("failed to initialize glfw");
        }
        glfwWindowHint(GLFW_CONTEXT_VERSION_MAJOR, 4);
        glfwWindowHint(GLFW_CONTEXT_VERSION_MINOR, 6);
        glfwWindowHint(GLFW_OPENGL_CORE_PROFILE, GLFW_OPENGL_CORE_PROFILE);

        m_Monitor = glfwGetPrimaryMonitor();

        const GLFWvidmode *mode = glfwGetVideoMode(m_Monitor);
        glfwWindowHint(GLFW_RED_BITS, mode->redBits);
        glfwWindowHint(GLFW_GREEN_BITS, mode->greenBits);
        glfwWindowHint(GLFW_BLUE_BITS, mode->blueBits);
        glfwWindowHint(GLFW_REFRESH_RATE, mode->refreshRate);

        m_Window = glfwCreateWindow(mode->width, mode->height, m_Title.c_str(), fullscreen ? m_Monitor : NULL, NULL);

        if (m_Window == nullptr)
        {
            throw std::runtime_error("failed to create glfw window");
        }
        glfwMakeContextCurrent(m_Window);
        glfwSetFramebufferSizeCallback(m_Window, framebufferSizeCallback);

        if (!gladLoadGLLoader((GLADloadproc)glfwGetProcAddress))
        {
            throw std::runtime_error("failed to load gl");
        }
        glViewport(0, 0, m_Width, m_Height);
    }

    MykaEngine::MykaWindow::~MykaWindow()
    {
        glfwDestroyWindow(m_Window);
        glfwTerminate();
    }

    bool MykaWindow::shouldClose() const
    {
        return glfwWindowShouldClose(m_Window);
    }

    void MykaWindow::pollEvents() const
    {
        glfwPollEvents();

        if (glfwGetKey(m_Window, GLFW_KEY_T) == GLFW_PRESS)
        {
            glEnable(GL_POLYGON_SMOOTH);
            glPolygonMode(GL_FRONT_AND_BACK, GL_LINE);
        }
        if (glfwGetKey(m_Window, GLFW_KEY_T) == GLFW_RELEASE)
        {
            glDisable(GL_POLYGON_SMOOTH);
            glPolygonMode(GL_FRONT_AND_BACK, GL_FILL);
        }
        if (glfwGetKey(m_Window, GLFW_KEY_ESCAPE) == GLFW_PRESS)
        {
            glfwSetWindowShouldClose(m_Window, GLFW_TRUE);
        }
    }

    void MykaWindow::swapBuffers() const
    {
        glfwSwapBuffers(m_Window);
    }

    void MykaWindow::setWindowTitle(const std::string &title)
    {
        m_Title = title;
        glfwSetWindowTitle(m_Window, m_Title.c_str());
    }

    GLFWwindow *MykaWindow::getWindow()
    {
        return m_Window;
    }

    void MykaWindow::framebufferSizeCallback(GLFWwindow *window, int width, int height)
    {
        glViewport(0, 0, width, height);
    }
} // namespace MykaEngine

